---
title: 不重复循环
status: TODO
---


## 题目

<%- include("./problem.md") _%>

## 解析

只针对样例,我们可以这样思考🤔:从3个位置中选2个位置来放1,剩下的1个位置来放2,那么方案数为:``C_{3}^{2}``

但是面对复杂的数据的时候,有没有一种方法可以生成所有的方案的方法呢?

按下面的方法来操作,可以生成符合题目要求的所有方案


使用代码来描述方法.

代码

```cpp
1. 设``m``表示不同的数字的数量
2. 建立``m``个桶,相同的数字放到一个桶里,``a[i]``表示第``i``种数字的放到桶里后,桶里数字的数量
3. ``n``个位置,按顺序挑数字,方法如下
  - 第1个位置,从``m``里选一个非空的桶``j``
  - 从桶``j``里拿一下数字放入第1个位置
  - 第2个位置然后在挑选
  - 第3个位置然后在挑选
  - ``\cdots``
  - 第n个位置然后在挑选
4. 重复,回溯操作``3``,就可以生成所有的方案
```

核心:每个位置只有m种可能性

## 证明

如何证明上面的方法生成的方案不多不少?!!!!!!? 正好不生成不重复的方案

```
1(1) 1(2) x
1(2) 1(1) x
```

使用数学归纳法

当``n=1``时,也就是只有一个位置时,按上面的方法操作,显然得到答案为``m``,正确.

```math
f(1,s) = \sum_{1}^{m} x(i)
```

当``n=2``时,也就是有2位置时

,使用集合分类的思想,按,我们可以把所有的方案分成以下的几种

核心:第1个位置有m种可能性!!!!!

为什么每个位置有m种可能性!!!

怎么才能不重复??


```
1(1) 1(2) x
1(2) 1(1) x
```

不能出现这种情况?怎么才能不出现?????

从一个箱子拿,每个人都拿完,只有一种可能性,证明法:暴力验证.
从2个箱子里拿,不会重复.




```math
f(i,si) = \sum_{i}^{m}  f(i-1,s_{i-1}) | a[i] \geslant 1

有条件的sum的公式,怎么写
```


## 数学公式

当前的方案数,与n个数字的状态,(m,a[i]),有关


## 代码

<%- include("./not_repeat_permutation.md") _%>


