[[TOC]]


## 题目


<%- include("./problem.md") %>

## 一句话算法

::: oneWordAlgo
每个元素都尝试拼接到它前面的所有元素的后面
:::

题目

TODO

本题是建立在序列上一个题目.

什么是序列?

根据[序列 - 维基百科，自由的百科全书](https://zh.wikipedia.org/wiki/%E5%BA%8F%E5%88%97)的定义，序列定义在集合上的一个函数$f:\mathbb{N} \rightarrow S$，而函数是定义在集合上的一种特殊二元关系。可以直观的把序列理解成排成一列的数。

## 暴力想法
根据前面所学的集合的知识，设集合为$S = \{a_1,a_2,\cdots,a_n\}$,设问题:在集合$S$上的$Lis$的值,表示为$f(S)$,

设序列$Q = a_1,a_2,\cdots,a_n$,表示原序列.

设$Q$的子序列表示为$q_i$

那么$q_i$具体是什么呢?

设$Q = 1,2,3$时,那么,如下的列表


$$
\begin{array}{cccc}
i & bin(i) & \text{subsequec} \\
\hline \\
p_0 & 000 & \varnothing \\
p_1 & 001 & 1 \\
p_2 & 010 & 2\\
p_3 & 011 & 1,2\\
p_4 & 100 & 3 \\
p_5 & 101 & 1,3\\
p_6 & 110 & 2,3\\
p_7 & 111 & 1,2,3\\
\end{array}
$$

于是得知子序列$p_i$里的元素与下标$i$对应的二进制$bin(i)$有关:

- 如果$bin(i)$第$j$位为$0$,表示子序列$p_i$不含有$a_{j+1}$
- 如果$bin(i)$第$j$位为$1$,表示子序列$p_i$含有$a_{j+1}$


数学表示为

$$
p_i = [a_j \mid i \& (1\ll(j-1)) = 1]
$$

设$P$表示子序列$p_i$组成的集合$P = \{p_0,p_1,\cdots p_{2^n}\}$,n表示$Q$的元素的个数

序列是定义在集合上的一个函数

函数是一种特殊的二元关系

显然答案是

$$
ans = max\{ len(p) \mid p \in P \land isLis(p) \} \tag 1
$$

根据上面的式子$(1)$写出一个暴力求子集然后判断是否是Lis的代码,即可.


也就是集合$S$的所有子集$x$组合的集合$P(S) = \{x | x \subseteq S\}$,$P(S)$叫做集合$S$的幂集.

显然集合$x$是有
对子集$x$进行编码,

说了那么多,其实使用的算法很简单,就是[[[rbook: 01_seq]]]

::: fold
```cpp
<%- include("./force.cpp")%>
```
:::

## 小朋友法

原问题,设序列为$S$,求序列$S$上的$LIS$的值,表示$G(S)$

把这个问题转化为$f(i)$:第$i$个元素为结尾的$LIS$的值

$$
G(S) = max\{f(1),f(2),\cdots,f(n) \}
$$

这样就转化成了求$f(i)$问题,如何求呢,

显然

$$
f(i) = max\{1,f(j)+1\} \; j < i \land a_j < a_i
$$

于是我们只需要写一个两重循环可以解出答案,时间为$O(n^2)$


## 代码

```cpp
<%- include("./std.cpp")%>
```

时间复杂度为:$O(n^2)$


## 证明

上面我们通过小朋友法,得到了一个式子如下:

$$
G(S) = max\{f(1),f(2),\cdots,f(n) \}
$$

似乎很突兀,你可能会有两个疑问:

1. 如何证明这个公式是正确的
2. 如何思考可以最终得到这个公式呢?思维的过程是什么.

下面的用集合想法来证明.

设原序列为$S = a_1, a_2, a_3, a_4, a_5, a_6, a_7$,$P(7)$表示序列$S$的前$7$个元素的所有子集组成的集合,设$x \in P(7)$

> 用数字$n$表示一个前n个元素组成的集合是一种常用的集合表示法.

设$g(x)$表示$x$对应的$lis$值,具体如下:

```math
g(x) = \left\{
    \begin{aligned}
        &\vert x \vert & x \text{各个元素是符合Lis的} \\
        &0 & \text{如果$x$是空集}\\
    \end{aligned}
\right. 
```


根据集合分类的思想,考虑是后一个元素,要么包含最后一个元素$a_7$,要么不包含

根据最后一个元素$a_7$,是否包含,把$P(7)$里的元素分成了两类

- $P_{a_7}(7)$ ,含有$a_7$的子集集合
- $P_{ \bcancel{a_7}}(7)$,不含有$a_7$的子集集合


那么需要求前$7$个元素的能得到的最大$lis$值

设$G(7)$表示$P(7)$中符合条件的最长的那个元素的长度

- $G_{a_7}(7) = f(7)$,$P_{a_7}(7)$ ,含有$a_7$的的子集的答案
- $G_{ \bcancel{a_7}}(7) = G(6)$,针对$P_{ \bcancel{a_7}}(7)$,得到的答案

```math
G(7) =
\left\{
    \begin{aligned}
        &G_{a_7}(7) = f(7) \\
        &G_{\bcancel{a_7}}(7) = G(6) \\
    \end{aligned}
\right.
```

显然$G(6)$还可以继续分解

```math
G(7) =
\left\{
    \begin{aligned}
        &G_{a_6}(6) = f(6) \\
        &G_{\bcancel{a_6}}(6) = G(5) \\
    \end{aligned}
\right.
```


如果按这种方式继续分,可以分成到最后一个式子是

```math
G(1) =
\left\{
    \begin{aligned}
        &G_{a_1}(1) = f(1) = 1 \\
        &G_{\bcancel{a_1}}(1) = G(0) = 0 \\
    \end{aligned}
\right.
```

可以想到,按这方式对集合进行划分,符合**不重不漏**的原则,且最后所有的问题都可以转成$f(i)$,于是我们成功的把原问题转成了$max\{\}$

显然$f(S)$分解成了一子问题$g(S,a_n)$与原问题不相似,连参数都不一样,这不一种好的分解子问题的方式,或集合分类方式.但这启发了我们.

为了方法,我们用数字来表示集合,如$4$,就是表示前$4$个元素表示的集合$\{a_1,a_2,a_3,a_4\}$

显然,可以用$g(n,a_n)$来表示前$n$个元素组成的集合,且一定含有的$a_n$最为最后一个元素的$lis$的值

那么

$$
g(n,a_n) = max(\{g(i,a_i) \big\vert i \leqslant n \land a_i \leqslant a_n \}) +1
$$

$g(n,a_n)$的答案,就是符合条件的子集合组成的集合的最值加$1$,成功建立起和子集合之间的关联

$$
f(S) = max(\{g(i,a_i) \big\vert i \in [1,n]\})
$$

建立起了最终问题与$g$的关联.

##  思考

本质上可以把这个题目看成一个竖着的单列数字金字塔,只不过从点$i$到达某个点$j$是有条件的.

## 练习题目

<%- include("practice.md") %>
