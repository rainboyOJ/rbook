# 数学金字塔

## 说明

本节内容的前置知识为

- 集合
  - 集合分成不重不漏的子集
- 组合数学


## 题目描述

<%- include("./problem.md") %>


## 搜索1 : 枚举

这里采用最朴素,最简单的想法,类似走迷宫(TODO)的思路: 枚举出所有可能的路线,找出所有路线中值最大的.

如何枚举所有可能的路线呢?我们想像有一个人在金字塔上行走,在某一时刻,他处于$(x,y)$这个点,那么$(x,y)$这个坐标值就是这个人的**状态**,下一个时刻,他可能走1.$(x+1,y)$,2.$(x+1,y+1)$这两个点,如果走到了边界$x = n$,那他就**回溯**,所以我们使用**递归**法,记录所走过的路径,就可以求出所有可能走的路线的线路了.

::: fold
```cpp
<%- include("./dfs_0.cpp")%>
```
:::

算法的时间同样为$2^{n-1}$.面对最大数据$1000$时会超时.

## 搜索2 : 小朋友法,列公式

设$f(i,j)$表示从点$(i,j)$开始向下走到最后一层能得到的最大值.

于是我们得到了一个推导公式

$$
f(i,j) = 
\left\{
\begin{array}{cc}
    max(f(i+1,j),f(i+1,j+1)) + a[i][j] & i != n\\
    a[i][j] & i == n
\end{array}
\right. \tag a
$$

如果这样思考,就类似于: 处于点$(x,y)$的小朋友,去询问$(x+1,y),(x+1,y+1)$的小朋友: 从他们所在的坐标开始走能得到的最大值是什么.

::: fold
```cpp
<%- include("./dfs.cpp")%>
```
::: 


算法的时间同样为$2^{n-1}$.面对最大数据$1000$时会超时.

## 记忆化优化

为什么dfs要比dp慢那么呢?**因为dfs为重复的计算子问题**

TODO : 详细的讲一下:


```cpp
<%- include("./dfs_memory.cpp")%>
```

## dp来做

考虑到分解子问题的$f(i,j)$

那么到达$(i,j)$的下一个点的值$f(i+1,j),f(i+1,j+1)$的值是固定的

如果可以得到先得到第$i+1$层的所有的$f$值,那不就可以直接使用`for循环得到第$i$层的所有的值了吗?

TODO : 图

显然我可以轻松的得到最后一层的$f$值,因为最一层不需要再向下走了,可以想像成只有一层的金字塔.

$$
f(i,j) = a[i][j] \text{i是最后一层},i == n
$$

于是可以想到,

1. 先得到最后一层,也就是第n层
2. 然后利用第n层的值,得到第$n-1$层的值
3. ...
4. 利用第$2$层的值,得到第$1$层的值
我们手动的推导一遍

于是我们就是原来的由上到下(大问题分解子问题)的dfs,变成了由下到上(子问题推出大问题)的dp


代码


```cpp
<%-include("./dp.cpp")%>
```

## 集合

从集合的角度思考问题

结论,本质上来说,dp就是集合的分解


DP之间的关系:如何从A集合得到B集合

## DP相关概念

阶段: 就是上面描述的层.



## 练习题目

- <%- pid_to_url('luogu', '1216','数字三角形') %>
- <%- pid_to_url('roj', '1262','挖地雷') %>
- <%- pid_to_url('noiopenjudge', 'ch0206/2728','摘花生') %>
- <%- pid_to_url('noiopenjudge', 'ch0206/4982','踩方格') %>
