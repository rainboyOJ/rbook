# 数学金字塔


## 题目描述


## 搜索

设$f(i,j)$表示从点$(i,j)$开始向下走到最后一层能得到的最大值.

于是我们得到了一个推导公式

$$
f(i,j) = 
\left\{
\begin{array}{cc}
    max(f(i+1,j),f(i+1,j+1)) + a[i][j] & i != n\\
    a[i][j] & i == n
\end{array}
\right. \tag a
$$

```cpp
<%- include("./dfs.cpp")%>
```



## 记忆化

为什么dfs要比dp慢那么呢

```cpp
<%- include("./dfs_memory.cpp")%>
```

## dp来做

考虑到分解子问题的$f(i,j)$

那么到达$(i,j)$的下一个点的值$f(i+1,j),f(i+1,j+1)$的值是固定的

如果可以得到先得到第$i+1$层的所有的$f$值,那不就可以直接使用`for循环得到第$i$层的所有的值了吗?

TODO : 图

显然我可以轻松的得到最后一层的$f$值,因为最一层不需要再向下走了,可以想像成只有一层的金字塔.

$$
f(i,j) = a[i][j] \text{i是最后一层},i == n
$$

于是可以想到,

1. 先得到最后一层,也就是第n层
2. 然后利用第n层的值,得到第$n-1$层的值
3. ...
4. 利用第$2$层的值,得到第$1$层的值
我们手动的推导一遍

于是我们就是原来的由上到下(大问题分解子问题)的dfs,变成了由下到上(子问题推出大问题)的dp


代码

## 集合

从集合的角度思考问题

结论,本质上来说,dp就是集合的分解


DP之间的关系:如何从A集合得到B集合

## DP相关概念

阶段: 就是上面描述的层.



## 练习题目

- <%- pid_to_url('luogu', '1216','数字三角形') %>
- <%- pid_to_url('roj', '1262','挖地雷') %>
- <%- pid_to_url('noiopenjudge', 'ch0206/2728','摘花生') %>
- <%- pid_to_url('noiopenjudge', 'ch0206/4982','踩方格') %>