## 题目2: 直方图中最大的矩形

题目地址: <%- pid_to_url("roj","3032","Largest Rectangle in a Histogram」 直方图中最大的矩形") %>

## 解析

已知

1. 由题目数据$n \leqslant 10^5$知,算法应该是扫一遍就能得答案,
2. 设$f(i)$表示可以整体问题可以转化成:$\max(f(i)),i \leqslant n$


根据我一[[../../mind_theory/|放大缩小]]法的思维方式,

### 情况1: 高度一样

首先想到: 情况1: 如果所有的矩形的高度都一样,显然可以直接用矩形的数量乘以高度作为答案.这个问题变成十分简单.

### 情况2: 高度有序

情况2:矩形的高度从左到右单调增加.给每个矩形编号如下图

![](./asy/figrure1.svg)

以$i$为开头的面积为: 矩形$i$向右投影的面积: $(4-i-1) * height_i$,这样只需要扫一遍数组就可以得到答案,时间为$O(n)$.

::: line
![](./asy/figure2_1.svg)
![](./asy/figure2_2.svg)
![](./asy/figure2_3.svg)
![](./asy/figure2_4.svg)
:::

那么以矩形$i$为结尾如何求最值大面积值呢?此时我们想要考虑向左投影.考虑最后一个矩形$4$,它对$1,2,3$的贡献如下

::: line
![](./asy/figure3_4.svg)
![](./asy/figure3_3.svg)
![](./asy/figure3_2.svg)
![](./asy/figure3_1.svg)
:::

当矩形$4$对前面的贡献的高度,越来越低.

我们用如下的伪代码来描述我们的思想

::: pseudocode
\state w=0
\for{$i=4$ \TO $1$}
    \state w++;
    \state ans = max(ans,$w \times height_i$) 
\endfor
\print ans
:::

可以想到: 我们不停的从后向前扫描矩形,然后维护一个宽度为$w$,高度不停降低的矩形(共享).也可以这样理解:我们不停的删除矩形上部的无用的部分.

![](./asy/figure4.svg)

于是我们得到一个结论:++当数据是有序时,我们可以轻松的解决题目++,时间$O(n)$

### 情况3: 数据是无序

根据集合的分类思想`[[../../enumerationg_permutations/|pair_number]`,如果我们能++不漏++的(可以重复)求出所有的以第$i$矩形为结尾向左投影面积,那么就可以解决这个最值问题.

![](./asy/figure5.svg)


x左边的矩形,是单调减的,这就是情况2.

以上图的$x$矩形,如果要求出x向左投影的所有面积,显然左边的所有的比$x$高的部分都没有意义,全部删除,维护一个高度为$height_x$的大矩形.


x右侧的比较x高的矩形,例如$y$,它的投影经过$x$时,高度会变成$x$的高度,也就说:++x的删除操作不会影响到y的投影面积求取++.和光的投影一样.

如果$height_y < height_x$,那不就是上面说的?

因为y后的单调增加,还是变成了情况2-1.在最后求出一个单调上长的矩形.


新出现的一个矩形$z$,它的高度有两种情况:

- 比前面的高
- 比前面的低

无论哪种情况,我们总是能转化为已知的操作来做.


以第i个矩形向右投影,就可以得到以第i个矩形为开头的面积了.

反过来思考,如果矩形是单调减的,那只要考虑以第i个矩形为结尾就可以了.


证明:按上面的操作,不漏:
即,问题$f(i)$以i为结尾的向左投影面积

然后认识到这种操作就是栈上的操作,于是用了栈来维护.


::: oneWordAlgo
核心思想: 
1. **截取**
2. 截取不会影响对后面的贡献
:::


## 代码实现

```cpp
<%- include("acw_131.cpp") _%>
```
